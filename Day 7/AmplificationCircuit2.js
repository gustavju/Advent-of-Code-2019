let inputData = [
  3,
  8,
  1001,
  8,
  10,
  8,
  105,
  1,
  0,
  0,
  21,
  46,
  59,
  84,
  93,
  110,
  191,
  272,
  353,
  434,
  99999,
  3,
  9,
  101,
  2,
  9,
  9,
  102,
  3,
  9,
  9,
  1001,
  9,
  5,
  9,
  102,
  4,
  9,
  9,
  1001,
  9,
  4,
  9,
  4,
  9,
  99,
  3,
  9,
  101,
  3,
  9,
  9,
  102,
  5,
  9,
  9,
  4,
  9,
  99,
  3,
  9,
  1001,
  9,
  4,
  9,
  1002,
  9,
  2,
  9,
  101,
  2,
  9,
  9,
  102,
  2,
  9,
  9,
  1001,
  9,
  3,
  9,
  4,
  9,
  99,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  99,
  3,
  9,
  102,
  2,
  9,
  9,
  1001,
  9,
  5,
  9,
  1002,
  9,
  3,
  9,
  4,
  9,
  99,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  101,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  101,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  101,
  2,
  9,
  9,
  4,
  9,
  99,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  2,
  9,
  4,
  9,
  99,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  99,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  99,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  1,
  9,
  4,
  9,
  3,
  9,
  101,
  1,
  9,
  9,
  4,
  9,
  3,
  9,
  102,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  101,
  2,
  9,
  9,
  4,
  9,
  3,
  9,
  1002,
  9,
  2,
  9,
  4,
  9,
  3,
  9,
  1001,
  9,
  2,
  9,
  4,
  9,
  99
];

const runIntCodeComp = cfg => {
  const getParam = (parameterMode, argIndex) =>
    // Parametermode 0 = positionMode, 1 = immediate mode;
    parameterMode == 0 ? cfg.data[cfg.data[argIndex]] : cfg.data[argIndex];

  while (cfg.pointer < cfg.data.length) {
    let opCode = cfg.data[cfg.pointer];
    while (opCode.toString().length < 5) {
      opCode = '0' + opCode;
    }

    const [pm3, parameterMode2, parameterMode1, op2, op1] = opCode.split(''); // pm3 kommer aldrig att anv채ndas
    const param1 = getParam(parameterMode1, cfg.pointer + 1);
    const param2 = getParam(parameterMode2, cfg.pointer + 2);
    const param3Index = cfg.data[cfg.pointer + 3];

    switch (op1) {
      case '1':
        cfg.data[param3Index] = param1 + param2;
        cfg.pointer += 4;
        break;
      case '2':
        cfg.data[param3Index] = param1 * param2;
        cfg.pointer += 4;
        break;
      case '3':
        cfg.data[cfg.data[cfg.pointer + 1]] = cfg.queue.shift();
        cfg.pointer += 2;
        break;
      case '4':
        let outputVal = cfg.data[cfg.data[cfg.pointer + 1]];
        cfg.pointer += 2;
        return outputVal;
      case '5':
        cfg.pointer = param1 != 0 ? param2 : cfg.pointer + 3;
        break;
      case '6':
        cfg.pointer = param1 == 0 ? param2 : cfg.pointer + 3;
        break;
      case '7':
        cfg.data[param3Index] = param1 < param2 ? 1 : 0;
        cfg.pointer += 4;
        break;
      case '8':
        cfg.data[param3Index] = param1 == param2 ? 1 : 0;
        cfg.pointer += 4;
        break;
      case '9':
        done = cfg.id == 4; // s채tt done om vi 채r p책 sista amp:en
        return;
    }
  }
};

let done = false;
const main = () => {
  const permutations = permut('56789');
  let maxOutput = 0;
  permutations.forEach(permutation => {
    const phaseSettings = permutation.split('').map(Number);
    let lastSignal = 0;
    const config = phaseSettings.map((phase, index) => ({
      id: index,
      pointer: 0,
      data: [...inputData],
      queue: [phase]
    }));
    config[0].queue.push(0);
    done = false;
    let count = 0;
    while (!done) {
      const currAmp = count % 5;
      const nextAmp = (count + 1) % 5;
      const output = runIntCodeComp(config[currAmp]);
      if (output) {
        config[nextAmp].queue.push(output);
        lastSignal = output;
      }
      count++;
    }
    if (lastSignal > maxOutput) {
      console.log('New Max: ' + phaseSettings);
      maxOutput = lastSignal;
    }
  });
  console.log(maxOutput);
};

const permut = str => {
  if (str.length < 2) return str; // This is our break condition
  let permutations = []; // This array will hold our permutations
  for (let i = 0; i < str.length; i++) {
    let char = str[i];
    // Cause we don't want any duplicates:
    // if char was used already
    if (str.indexOf(char) != i) continue; // skpointer it this time
    let remainingString = str.slice(0, i) + str.slice(i + 1, str.length);
    for (let subPermutation of permut(remainingString))
      permutations.push(char + subPermutation);
  }
  return permutations;
};

main();

/*
const incrementPhase = phaseSettings => {
  ++phaseSettings[0];
  for (let index = 0; index < phaseSettings.length; index++) {
    if (phaseSettings[index] == 5) {
      phaseSettings[index] = 0;
      ++phaseSettings[index + 1];
    }
  }
  return phaseSettings;
};
*/
